diff --git a/src/device/device_io_dummy.cpp b/src/device/device_io_dummy.cpp
index f91e10651..bd7ec63b3 100644
--- a/src/device/device_io_dummy.cpp
+++ b/src/device/device_io_dummy.cpp
@@ -52,6 +52,10 @@ unsigned char* hw::io::device_io_dummy::receivedFromDevice = {};
 size_t hw::io::device_io_dummy::receivedFromDeviceLength = 0;
 bool hw::io::device_io_dummy::waitsForDeviceSend = false;
 bool hw::io::device_io_dummy::waitsForDeviceReceive = false;
+void (*hw::io::device_io_dummy::sendToLedgerDeviceCallback)(unsigned char *command, unsigned int cmd_len) = nullptr;
+std::mutex hw::io::device_io_dummy::mutex;
+std::condition_variable hw::io::device_io_dummy::cv_send;
+std::condition_variable hw::io::device_io_dummy::cv_receive;
 
 namespace hw {
     namespace io {
@@ -90,22 +94,29 @@ namespace hw {
 
         int device_io_dummy::exchange(unsigned char *command, unsigned int cmd_len, unsigned char *response, unsigned int max_resp_len, bool user_input)  {
             MDEBUG("exchange(): locking mutex");
-            boost::unique_lock<boost::mutex> lock(mutex);
+            std::unique_lock<std::mutex> lock(mutex);
             sendToDevice = command;
             sendToDeviceLength = cmd_len;
             waitsForDeviceSend = true;
             waitsForDeviceReceive = true;
+
+            // Call the callback if it's set
+            if (sendToLedgerDeviceCallback != nullptr) {
+                MDEBUG("exchange(): calling sendToLedgerDeviceCallback");
+                sendToLedgerDeviceCallback(command, cmd_len);
+            }
             MDEBUG("exchange(): waitsForDeviceSend");
-            // NOTE: waitsForDeviceSend should be changed by external code
+            // Wait for the send flag to be cleared by external code
             while (waitsForDeviceSend) {
-                std::this_thread::sleep_for(std::chrono::microseconds(1000));
-                MDEBUG("exchange(): waitsForDeviceSend (still)");
+                cv_send.wait(lock);
+                MDEBUG("exchange(): waitsForDeviceSend notified");
             }
 
             MDEBUG("exchange(): waitsForDeviceReceive");
+            // Wait for the receive flag to be cleared by external code
             while (waitsForDeviceReceive) {
-                std::this_thread::sleep_for(std::chrono::microseconds(1000));
-                MDEBUG("exchange(): waitsForDeviceReceive (still)");
+                cv_receive.wait(lock);
+                MDEBUG("exchange(): waitsForDeviceReceive notified");
             }
 
             if (receivedFromDeviceLength > max_resp_len) {
@@ -113,7 +124,7 @@ namespace hw {
                 return 1;
             }
 
-            memset(response,0,max_resp_len);
+            memset(response, 0, max_resp_len);
             memcpy(response, receivedFromDevice, receivedFromDeviceLength);
             return receivedFromDeviceLength;
         }
@@ -126,7 +137,24 @@ namespace hw {
             MDEBUG("release()");
         }
 
+        void device_io_dummy::setLedgerCallback(void (*sendToLedgerDevice)(unsigned char *command, unsigned int cmd_len)) {
+            MDEBUG("setLedgerCallback()");
+            sendToLedgerDeviceCallback = sendToLedgerDevice;
+        }
 
+        void device_io_dummy::setDeviceReceivedData(unsigned char* data, size_t len) {
+            MDEBUG("setDeviceReceivedData(len: " << len << ")");
+            std::unique_lock<std::mutex> lock(mutex);
+
+            receivedFromDevice = static_cast<unsigned char *>(malloc(len));
+            receivedFromDeviceLength = len;
+            memset(receivedFromDevice, 0, len);
+            memcpy(receivedFromDevice, data, len);
+            waitsForDeviceReceive = false;
+            waitsForDeviceSend = false;
+            cv_send.notify_all();
+            cv_receive.notify_all();
+        }
 
     }
 }
diff --git a/src/device/device_io_dummy.hpp b/src/device/device_io_dummy.hpp
index a1733616d..68dc93934 100644
--- a/src/device/device_io_dummy.hpp
+++ b/src/device/device_io_dummy.hpp
@@ -32,6 +32,8 @@
 
 #include "device_io.hpp"
 #include "device_io_hid.hpp"
+#include <mutex>
+#include <condition_variable>
 
 namespace hw {
     namespace io {
@@ -43,9 +45,11 @@ namespace hw {
         };
         class device_io_dummy : device_io {
         private:
-            boost::mutex mutex;
+            static std::mutex mutex;
 
         public:
+            static std::condition_variable cv_send;
+            static std::condition_variable cv_receive;
             static bool stateIsConnected;
             static unsigned char* sendToDevice;
             static size_t sendToDeviceLength;
@@ -53,6 +57,7 @@ namespace hw {
             static size_t receivedFromDeviceLength;
             static bool waitsForDeviceSend;
             static bool waitsForDeviceReceive;
+            static void (*sendToLedgerDeviceCallback)(unsigned char *command, unsigned int cmd_len);
 
             device_io_dummy()  = default;
             device_io_dummy(int a, int b, int c, int d);
@@ -67,6 +72,9 @@ namespace hw {
             bool connected() const;
 
             int  exchange(unsigned char *command, unsigned int cmd_len, unsigned char *response, unsigned int max_resp_len, bool user_input);
+
+            static void setLedgerCallback(void (*sendToLedgerDevice)(unsigned char *command, unsigned int cmd_len));
+            static void setDeviceReceivedData(unsigned char* data, size_t len);
         };
     };
 };
